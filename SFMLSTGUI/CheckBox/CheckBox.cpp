#include <iostream>

#include "CheckBox.hpp"

#include "..\dllmain.h"

using namespace std;
using namespace st;
using namespace sf;

const sf::Color outline_c(85, 85, 85);
const sf::Color sellect_c(0, 122, 204);
const sf::Color fill_c(51, 51, 55);


static Texture* check = nullptr;
static const Uint64 check_data_size = 774;
static sf::Uint8 check_data[] = {
	0x42, 0x4D, 0x06, 0x03, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x36, 0x00, 0x00, 0x00, 0x28, 0x00,
	0x00, 0x00, 0x0F, 0x00, 0x00, 0x00, 0x0F, 0x00,
	0x00, 0x00, 0x01, 0x00, 0x18, 0x00, 0x00, 0x00,
	0x00, 0x00, 0xD0, 0x02, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x2D,
	0x2D, 0x30, 0x2D, 0x2D, 0x30, 0x2D, 0x2D, 0x30,
	0x2D, 0x2D, 0x30, 0x2D, 0x2D, 0x30, 0x2D, 0x2D,
	0x30, 0x2D, 0x2D, 0x30, 0x2D, 0x2D, 0x30, 0x2D,
	0x2D, 0x30, 0x2D, 0x2D, 0x30, 0x2D, 0x2D, 0x30,
	0x2D, 0x2D, 0x30, 0x2D, 0x2D, 0x30, 0x2D, 0x2D,
	0x30, 0x2D, 0x2D, 0x00, 0x00, 0x00, 0x30, 0x2D,
	0x2D, 0x30, 0x2D, 0x2D, 0x30, 0x2D, 0x2D, 0x30,
	0x2D, 0x2D, 0x30, 0x2D, 0x2D, 0x30, 0x2D, 0x2D,
	0x30, 0x2D, 0x2D, 0x30, 0x2D, 0x2D, 0x30, 0x2D,
	0x2D, 0x30, 0x2D, 0x2D, 0x30, 0x2D, 0x2D, 0x30,
	0x2D, 0x2D, 0x30, 0x2D, 0x2D, 0x30, 0x2D, 0x2D,
	0x30, 0x2D, 0x2D, 0x00, 0x00, 0x00, 0x30, 0x2D,
	0x2D, 0x30, 0x2D, 0x2D, 0x30, 0x2D, 0x2D, 0x30,
	0x2D, 0x2D, 0x30, 0x2D, 0x2D, 0x30, 0x2D, 0x2D,
	0x30, 0x2D, 0x2D, 0x30, 0x2D, 0x2D, 0x30, 0x2D,
	0x2D, 0x30, 0x2D, 0x2D, 0x30, 0x2D, 0x2D, 0x30,
	0x2D, 0x2D, 0x30, 0x2D, 0x2D, 0x30, 0x2D, 0x2D,
	0x30, 0x2D, 0x2D, 0x00, 0x00, 0x00, 0x30, 0x2D,
	0x2D, 0x30, 0x2D, 0x2D, 0x30, 0x2D, 0x2D, 0x30,
	0x2D, 0x2D, 0x30, 0x2D, 0x2D, 0x53, 0x51, 0x51,
	0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x53, 0x51,
	0x51, 0x30, 0x2D, 0x2D, 0x30, 0x2D, 0x2D, 0x30,
	0x2D, 0x2D, 0x30, 0x2D, 0x2D, 0x30, 0x2D, 0x2D,
	0x30, 0x2D, 0x2D, 0x00, 0x00, 0x00, 0x30, 0x2D,
	0x2D, 0x30, 0x2D, 0x2D, 0x30, 0x2D, 0x2D, 0x30,
	0x2D, 0x2D, 0x30, 0x2D, 0x2D, 0x76, 0x75, 0x75,
	0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x76, 0x75,
	0x75, 0x30, 0x2D, 0x2D, 0x30, 0x2D, 0x2D, 0x30,
	0x2D, 0x2D, 0x30, 0x2D, 0x2D, 0x30, 0x2D, 0x2D,
	0x30, 0x2D, 0x2D, 0x00, 0x00, 0x00, 0x30, 0x2D,
	0x2D, 0x30, 0x2D, 0x2D, 0x30, 0x2D, 0x2D, 0x30,
	0x2D, 0x2D, 0x4A, 0x48, 0x48, 0x99, 0x99, 0x99,
	0x7F, 0x7E, 0x7E, 0x78, 0x77, 0x77, 0x99, 0x99,
	0x99, 0x51, 0x4F, 0x4F, 0x30, 0x2D, 0x2D, 0x30,
	0x2D, 0x2D, 0x30, 0x2D, 0x2D, 0x30, 0x2D, 0x2D,
	0x30, 0x2D, 0x2D, 0x00, 0x00, 0x00, 0x30, 0x2D,
	0x2D, 0x30, 0x2D, 0x2D, 0x30, 0x2D, 0x2D, 0x30,
	0x2D, 0x2D, 0x7F, 0x7E, 0x7E, 0x99, 0x99, 0x99,
	0x4A, 0x48, 0x48, 0x44, 0x42, 0x42, 0x99, 0x99,
	0x99, 0x85, 0x84, 0x84, 0x30, 0x2D, 0x2D, 0x30,
	0x2D, 0x2D, 0x30, 0x2D, 0x2D, 0x30, 0x2D, 0x2D,
	0x30, 0x2D, 0x2D, 0x00, 0x00, 0x00, 0x30, 0x2D,
	0x2D, 0x30, 0x2D, 0x2D, 0x30, 0x2D, 0x2D, 0x4A,
	0x48, 0x48, 0x99, 0x99, 0x99, 0x7F, 0x7E, 0x7E,
	0x30, 0x2D, 0x2D, 0x30, 0x2D, 0x2D, 0x76, 0x75,
	0x75, 0x99, 0x99, 0x99, 0x53, 0x51, 0x51, 0x30,
	0x2D, 0x2D, 0x30, 0x2D, 0x2D, 0x30, 0x2D, 0x2D,
	0x30, 0x2D, 0x2D, 0x00, 0x00, 0x00, 0x30, 0x2D,
	0x2D, 0x30, 0x2D, 0x2D, 0x30, 0x2D, 0x2D, 0x7F,
	0x7E, 0x7E, 0x99, 0x99, 0x99, 0x4A, 0x48, 0x48,
	0x30, 0x2D, 0x2D, 0x30, 0x2D, 0x2D, 0x53, 0x51,
	0x51, 0x99, 0x99, 0x99, 0x76, 0x75, 0x75, 0x30,
	0x2D, 0x2D, 0x30, 0x2D, 0x2D, 0x30, 0x2D, 0x2D,
	0x30, 0x2D, 0x2D, 0x00, 0x00, 0x00, 0x30, 0x2D,
	0x2D, 0x30, 0x2D, 0x2D, 0x30, 0x2D, 0x2D, 0x30,
	0x2D, 0x2D, 0x30, 0x2D, 0x2D, 0x30, 0x2D, 0x2D,
	0x30, 0x2D, 0x2D, 0x30, 0x2D, 0x2D, 0x30, 0x2D,
	0x2D, 0x76, 0x75, 0x75, 0x99, 0x99, 0x99, 0x53,
	0x51, 0x51, 0x30, 0x2D, 0x2D, 0x30, 0x2D, 0x2D,
	0x30, 0x2D, 0x2D, 0x00, 0x00, 0x00, 0x30, 0x2D,
	0x2D, 0x30, 0x2D, 0x2D, 0x30, 0x2D, 0x2D, 0x30,
	0x2D, 0x2D, 0x30, 0x2D, 0x2D, 0x30, 0x2D, 0x2D,
	0x30, 0x2D, 0x2D, 0x30, 0x2D, 0x2D, 0x30, 0x2D,
	0x2D, 0x53, 0x51, 0x51, 0x99, 0x99, 0x99, 0x76,
	0x75, 0x75, 0x30, 0x2D, 0x2D, 0x30, 0x2D, 0x2D,
	0x30, 0x2D, 0x2D, 0x00, 0x00, 0x00, 0x30, 0x2D,
	0x2D, 0x30, 0x2D, 0x2D, 0x30, 0x2D, 0x2D, 0x30,
	0x2D, 0x2D, 0x30, 0x2D, 0x2D, 0x30, 0x2D, 0x2D,
	0x30, 0x2D, 0x2D, 0x30, 0x2D, 0x2D, 0x30, 0x2D,
	0x2D, 0x30, 0x2D, 0x2D, 0x76, 0x75, 0x75, 0x99,
	0x99, 0x99, 0x53, 0x51, 0x51, 0x30, 0x2D, 0x2D,
	0x30, 0x2D, 0x2D, 0x00, 0x00, 0x00, 0x30, 0x2D,
	0x2D, 0x30, 0x2D, 0x2D, 0x30, 0x2D, 0x2D, 0x30,
	0x2D, 0x2D, 0x30, 0x2D, 0x2D, 0x30, 0x2D, 0x2D,
	0x30, 0x2D, 0x2D, 0x30, 0x2D, 0x2D, 0x30, 0x2D,
	0x2D, 0x30, 0x2D, 0x2D, 0x53, 0x51, 0x51, 0x99,
	0x99, 0x99, 0x76, 0x75, 0x75, 0x30, 0x2D, 0x2D,
	0x30, 0x2D, 0x2D, 0x00, 0x00, 0x00, 0x30, 0x2D,
	0x2D, 0x30, 0x2D, 0x2D, 0x30, 0x2D, 0x2D, 0x30,
	0x2D, 0x2D, 0x30, 0x2D, 0x2D, 0x30, 0x2D, 0x2D,
	0x30, 0x2D, 0x2D, 0x30, 0x2D, 0x2D, 0x30, 0x2D,
	0x2D, 0x30, 0x2D, 0x2D, 0x30, 0x2D, 0x2D, 0x30,
	0x2D, 0x2D, 0x30, 0x2D, 0x2D, 0x30, 0x2D, 0x2D,
	0x30, 0x2D, 0x2D, 0x00, 0x00, 0x00, 0x30, 0x2D,
	0x2D, 0x30, 0x2D, 0x2D, 0x30, 0x2D, 0x2D, 0x30,
	0x2D, 0x2D, 0x30, 0x2D, 0x2D, 0x30, 0x2D, 0x2D,
	0x30, 0x2D, 0x2D, 0x30, 0x2D, 0x2D, 0x30, 0x2D,
	0x2D, 0x30, 0x2D, 0x2D, 0x30, 0x2D, 0x2D, 0x30,
	0x2D, 0x2D, 0x30, 0x2D, 0x2D, 0x30, 0x2D, 0x2D,
	0x30, 0x2D, 0x2D, 0x00, 0x00, 0x00
};

CheckBox::CheckBox() :
	pos(Vector2f(0, 0)), state(State::Unchecked),
	cursor_on_object(false), pressed(false)
{
	fon.setOutlineThickness(1);
	fon.setOutlineColor(outline_c);
	fon.setFillColor(fill_c);
	fon.setSize(Vector2f(15, 15));

	checked_mixed.setSize(Vector2f(9, 9));
	checked_mixed.setFillColor(Color(153, 153, 153));

	size.y = 17;

	//load texture
	if (check == nullptr)
	{
		check = new Texture;
		check->loadFromMemory(check_data, check_data_size);
	}
	checked_s.setTexture(*check);

	text.setCharacterSize(11);

	setPosition(pos);
	calcSize();
}
CheckBox::~CheckBox()
{}

void CheckBox::setPosition(float x, float y)
{
	setPosition(Vector2f(x, y));
}
void CheckBox::setPosition(sf::Vector2f pos)
{
	this->pos = pos;

	checked_s.setPosition(Vector2f(pos.x + 1, pos.y + 1));
	fon.setPosition(Vector2f(pos.x+1, pos.y+1));
	checked_mixed.setPosition(Vector2f(pos.x + 4, pos.y + 4));
	text.setPosition(Vector2f(pos.x + 20, pos.y+1));
}
sf::Vector2f CheckBox::getPosition() const
{
	return pos;
}

sf::Vector2f CheckBox::getSize() const
{
	return size;
}

void CheckBox::setFont(const sf::Font& font)
{
	text.setFont(font);
	calcSize();
}

void CheckBox::setString(const sf::String& str)
{
	text.setString(str);
	calcSize();
}
const sf::String& CheckBox::getString() const
{
	return text.getString();
}

void CheckBox::setState(State s)
{
	state = s;
}
CheckBox::State CheckBox::getState() const
{
	return state;
}

void CheckBox::setChangeStateCallback(ChangeStateCallback change_state_callback)
{
	this->change_state_callback = change_state_callback;
}

bool CheckBox::event(const sf::Event& event, bool& focus)
{
	Vector2f c_pos(-1, -1); //позиция курсора
	bool o_focus = focus;   //фокус до начала обработки события
	bool ret = false;

	//////////////////////////курсор на объекте?///////////////////////
	//события кнопок
	if (event.type == Event::MouseButtonPressed ||
		event.type == Event::MouseButtonReleased)
	{
		c_pos = Vector2f(float(event.mouseButton.x), float(event.mouseButton.y));
		//На кнопке
		if (pos.x <= c_pos.x && c_pos.x <= pos.x + size.x &&
			pos.y <= c_pos.y && c_pos.y <= pos.y + size.y &&
			o_focus == false)
			cursor_on_object = true;
		else
			cursor_on_object = false;
	}
	//событие перемещения
	if (event.type == Event::MouseMoved)
	{
		c_pos = Vector2f(float(event.mouseMove.x), float(event.mouseMove.y));
		//На объекте
		if (pos.x <= c_pos.x && c_pos.x <= pos.x + size.x &&
			pos.y <= c_pos.y && c_pos.y <= pos.y + size.y &&
			o_focus == false)
			cursor_on_object = true;
		else
			cursor_on_object = false;
	}

	//установка фокуса
	if (!focus)
	{
		focus = cursor_on_object;
	}


	///////////////////////////////////////////////////////////////////////

	//цвет рамки
	if (event.type == Event::MouseMoved ||
		event.type == Event::MouseButtonPressed ||
		event.type == Event::MouseButtonReleased)
	{
		if (cursor_on_object && !o_focus)
			fon.setOutlineColor(sellect_c);
		else
			fon.setOutlineColor(outline_c);
	}

	//нажатие
	if (event.type == Event::MouseButtonPressed && event.mouseButton.button == Mouse::Left && cursor_on_object && !o_focus)
	{
		pressed = true;
	}
	//отжатие
	if (event.type == Event::MouseButtonReleased && event.mouseButton.button == Mouse::Left)
	{
		if (pressed && cursor_on_object && !o_focus)
		{
			if (state == State::Unchecked)
				state = State::Checked;
			else
				state = State::Unchecked;
			if (change_state_callback)
				change_state_callback(*this, state);
			ret = true;
		}

		pressed = false;
	}


	return ret;
}

void CheckBox::draw(sf::RenderTarget& target, sf::RenderStates states) const
{
	target.draw(fon);

	if (state == State::Checked)
		target.draw(checked_s);
	else if (state == State::Mixed)
		target.draw(checked_mixed);

	target.draw(text);
}

//private
void CheckBox::calcSize()
{
	size.x = 20 + text.getLocalBounds().width;
}